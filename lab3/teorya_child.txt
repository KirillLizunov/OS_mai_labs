#include <iostream>
#include <string>
#include <algorithm>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <sys/stat.h>
#include <cstring>
#include <cstdlib>

struct shared_data {
    sem_t sem_parent;
    sem_t sem_child;
    char buffer[1024];
    int terminate;
    char last_written[1024];
};

int main(int argc, char *argv[]) {
    if (argc != 2) {
        std::cerr << "Usage: ./child <shm_name>" << std::endl;
        return 1;
    }

//Что здесь происходит?

argc → количество аргументов.
argv[1] → имя объекта shared memory (/shm_child1 или /shm_child2).
Если аргумент не передан, выводится ошибка.


    const char *shm_name = argv[1];

    int shm_fd = shm_open(shm_name, O_RDWR, 0666);
    if (shm_fd == -1) {
        perror("Can't open shared memory object");
        exit(1);
    }

//Что делает shm_open()?

shm_open(shm_name, O_RDWR, 0666)
shm_name → имя (/shm_child1 или /shm_child2).
O_RDWR → открываем на чтение и запись.
0666 → права доступа (rw-rw-rw-).
Если не удалось открыть (shm_fd == -1) → 
выводим ошибку perror() и завершаем программу (exit(1)).

    shared_data *shm_ptr = (shared_data *) mmap(NULL, sizeof(shared_data), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("Can't mmap shared memory");
        exit(1);
    }

//Что делает mmap()?

mmap() отображает shared memory в адресное пространство процесса.
PROT_READ | PROT_WRITE → разрешаем чтение и запись.
MAP_SHARED → изменения видны всем процессам.


    while (true) {
//Бесконечный цикл — выполняется до получения сигнала завершения (terminate == 1).

        sem_wait(&shm_ptr->sem_parent);
//Что делает?

sem_wait() блокирует процесс до получения сигнала от родителя.
Пока родитель не вызовет sem_post(), процесс будет ждать.

    
        if (shm_ptr->terminate) {
            sem_post(&shm_ptr->sem_child);
            break;
        }
//Если terminate == 1, процесс завершает работу:

Разблокируем родителя (sem_post), чтобы он не завис.
Выходим из while, завершая процесс.
    
        // Проверяем, записывали ли мы уже эту строку
        if (strcmp(shm_ptr->buffer, shm_ptr->last_written) == 0) {
            sem_post(&shm_ptr->sem_child);
            continue;
        }
//Что делает?

strcmp() сравнивает buffer и last_written.
Если сообщение такое же, как предыдущее, процесс ничего не делает.
sem_post(&shm_ptr->sem_child); разблокирует родителя, чтобы он мог отправить новую строку.
continue; переходит к следующей итерации цикла.
    
        // Копируем строку в last_written перед записью
        strcpy(shm_ptr->last_written, shm_ptr->buffer);
    
        // Разворачиваем строку
        std::string str(shm_ptr->buffer);
        std::reverse(str.begin(), str.end());
        
        strcpy(shm_ptr->last_written, shm_ptr->buffer);

        // Записываем в файл (stdout перенаправлен)
        std::cout << str << std::endl;
        std::cout.flush();
    
        sem_post(&shm_ptr->sem_child);
//Разблокируем родителя, чтобы он знал, что обработка завершена.

    }            

    munmap(shm_ptr, sizeof(shared_data));
    close(shm_fd);
//Отключаем shared memory и закрываем её.

    return 0;
}



-------------------------------------------------------------------------




Теория:

1. размер блока дискового пространства

- это минимальный размер единицы хранения на диске, который может быть выделен для файла.
Размер блока зависит от файловой системы:
ext4 (Linux)	4 KB (по умолчанию), но можно 1 KB – 64 KB
NTFS (Windows)	4 KB (по умолчанию), можно 512 B – 64 KB


2. Размер объекта shm_open при создании

Если просто вызвать:
int shm_fd = shm_open("/my_shm", O_CREAT | O_RDWR, 0666);
Будет создан объект размером 0 байтов.
Без ftruncate() его нельзя использовать с mmap().
Чтобы задать размер:
ftruncate(shm_fd, sizeof(shared_data));
Теперь объект будет sizeof(shared_data) байтов.


3. Бывают ли случаи, когда mmap() копирует данные?

Обычно mmap() не копирует данные, а отображает файл или область памяти в адресное пространство процесса. 
Но есть исключения, когда mmap() может выполнять копирование данных.

3.1. MAP_PRIVATE и запись

mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
Если файл отображён с MAP_PRIVATE (приватное отображение), то при записи создаётся копия страницы (Copy-on-Write, COW).
Чтение не создаёт копию.

3.2. MAP_ANONYMOUS

mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
MAP_ANONYMOUS создаёт новый участок памяти (обычно инициализированный нулями).
Это не "копирование" данных, но создаётся новая область памяти.

3.3. При mremap()

Если память расширяется, но нет места рядом, mremap() может скопировать содержимое в новый участок:

ptr = mremap(ptr, old_size, new_size, MREMAP_MAYMOVE);


4. Как создаются файлы в Linux?

Файлы создаются системным вызовом open() или creat().


5. Системные вызовы файлового пространства

Файлы в Linux управляются через системные вызовы ядра.

Основные системные вызовы работы с файлами:

Системный вызов	Описание
open()	Открывает файл
creat()	Создаёт файл open() с `O_CREAT
read()	Читает из файла
write()	Записывает в файл
close()	Закрывает файл
lseek()	Перемещает указатель чтения/записи
stat()	Получает информацию о файле
fstat()	Получает информацию о файле по fd
unlink()	Удаляет файл
truncate()	Меняет размер файла

6. Процесс 

— это просто экземпляр выполняемой программы, включая текущие значения счетчика команд, регистров и переменных.

7. способы завершения процесса

Рано или поздно новые процессы будут завершены, обычно в силу следующих обстоятельств:
обычного выхода (добровольно);
выхода при возникновении ошибки (добровольно); 
возникновения фатальной ошибки (принудительно); 
уничтожения другим процессом (принудительно).

Большинство процессов завершаются по окончании своей работы. Когда компилятор откомпилирует заданную ему программу, он осуществляет системный вызов, сообща- 
ющий операционной системе о завершении своей работы. Этим вызовом в UNIX яв- ляется exit, а в Windows — ExitProcess. 
Программы, работающие с экраном, также поддерживают добровольное завершение. Текстовые процессоры, интернет-браузеры и аналогичные программы всегда содержат значок или пункт меню, на котором поль- 
зователь может щелкнуть, чтобы приказать процессу удалить все временные файлы, которые им были открыты, и завершить свою работу.

Вторая причина завершения — обнаружение процессом фатальной ошибки. Например, если пользователь наберет команду
cc foo.c
с целью компиляции программы foo.c, а файла с таким именем не будет, то произойдет простое объявление о наличии данного факта и выход из компилятора. Выхода из ин- 
терактивных, использующих экран процессов при задании им неверных параметров обычно не происходит. Вместо этого появляется диалоговое окно с просьбой о повтор- 
ной попытке ввода параметров.

Третья причина завершения — ошибка, вызванная самим процессом, чаще всего связанная с ошибкой в программе. В качестве примеров можно привести неверную инструкцию, 
ссылку на несуществующий адрес памяти или деление на нуль. В не- 
которых системах (например, UNIX) процесс может сообщить операционной системе о своем намерении обработать конкретные ошибки самостоятельно, в таком случае, 
когда встречается одна из таких ошибок, процесс получает сигнал (прерывается), а не завершается.

Четвертая причина, из-за которой процесс может быть завершен, — это выполнение процессом системного вызова, приказывающего операционной системе завершить некоторые другие процессы. 
В UNIX этот вызов называется kill. Соответствующая функция Win32 называется TerminateProcess. В обоих случаях у процесса, вызывающего завершение, должны быть на это соответствующие полномочия. 
В некоторых системах при добровольном или принудительном завершении процесса тут же завершаются и все созданные им процессы. Но ни UNIX, ни Windows так не делают.


8. способы инициализации процесса

существуют четыре основных события, приводящих к созданию процессов.
1. Инициализациясистемы.
2. Выполнение работающим процессом системного вызова, предназначенного для создания процесса.
3. Запрос пользователя на создание нового процесса.
4. Инициация пакетного задания.


9. Элементы процесса

Процесс в ОС — это исполняемая программа в памяти, состоящая из:

Элемент	Описание
Код (text segment)	    Машинные инструкции (исполняемый код).
Данные (data segment)	Глобальные и статические переменные.
Куча (heap)	            Динамически выделяемая память (malloc, new).
Стек (stack)	        Локальные переменные, вызовы функций.
Регистры процессора	    Содержат данные для выполнения инструкций (EIP, ESP, EAX и т. д.).
Открытые файлы	        Дескрипторы файлов (stdin, stdout, stderr).
Окружение	            Переменные окружения (PATH, HOME).
Семафоры, IPC	        Межпроцессное взаимодействие (pipes, shared memory).


10. Как устроен процесс?

Жизненный цикл процесса:

Создание (fork(), exec(), clone()).
Запуск (попадает в планировщик CPU).
Выполнение (исполняет код).
Ожидание (например, sleep(), sem_wait()).
Завершение (exit(), SIGTERM).


11. Устройство памяти процесса

+-----------------------+  Высокие адреса памяти (верх стека)
| Стек (Stack)         |  ↓ Растёт вниз
|-----------------------|
| Динамическая память  |  (Heap, растёт вверх)
| (malloc, new)        |
|-----------------------|
| Данные (Data)        |  Глобальные и статические переменные
|-----------------------|
| Код (Text)           |  Машинные инструкции программы
+-----------------------+  Низкие адреса памяти


12. Что такое Memory Mapping (отображение памяти)?

Memory mapping (отображение памяти) — это механизм, который позволяет привязать файл или область памяти к виртуальному адресу процесса.

Простой пример использования mmap:

void *ptr = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
Как это работает?

ОС привязывает файл или память к виртуальному адресу.
Данные читаются напрямую из памяти, без read()/write().
Можно делить память между процессами (MAP_SHARED).